{"mappings":"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","sources":["src/app.ts"],"sourcesContent":["async function app() {\n    const canvas = document.querySelector(\"canvas\");\n    \n    //@ts-ignore\n    if (!navigator.gpu) {\n        throw new Error(\"WebGPU not supported on this browser.\");\n    }\n    //@ts-check\n    const adapter = await navigator.gpu.requestAdapter();\n    if (!adapter) {\n        throw new Error(\"No appropriate GPUAdapter found.\");\n    }\n\n    const device = await adapter.requestDevice();\n    const context = canvas!.getContext(\"webgpu\");\n    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n    context.configure({\n        device: device,\n        format: canvasFormat,\n    });\n\n    const gridSize = 64\n    const workGroupSize = 8\n\n    \n\n    const vertices = new Float32Array([\n        //   X,    Y,\n        -0.8, -0.8,\n        0.8, -0.8,\n        0.8, 0.8,\n\n        -0.8, -0.8,\n        0.8, 0.8,\n        -0.8, 0.8,\n    ]);\n\n    const uniformArray = new Float32Array([gridSize, gridSize])\n    const uniformBuffer = device.createBuffer({\n        label: \"Grid Uniforms\",\n        size: uniformArray.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(uniformBuffer, 0, uniformArray);\n\n    const vertexBuffer = device.createBuffer({\n        label: \"Cell vertices\",\n        size: vertices.byteLength,\n        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    });\n\n   \n    device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/0, vertices);\n\n    // Create an array representing the active state of each cell.\n    const cellStateArray = new Uint32Array(gridSize * gridSize);\n\n    // Create a storage buffer to hold the cell state.\n    const cellStateStorage = [\n        device.createBuffer({\n            label: \"Cell State A\",\n            size: cellStateArray.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n        }),\n        device.createBuffer({\n            label: \"Cell State B\",\n            size: cellStateArray.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n        }),\n        device.createBuffer({\n            label: 'Cell State Input Buffer',\n            size: cellStateArray.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST\n        })\n    ];\n\n// Set each cell to a random state, then copy the JavaScript array \n// into the storage buffer.\nfor (let i = 0; i < cellStateArray.length; ++i) {\n    cellStateArray[i] = Math.random() > 0.9 ? 1 : 0;\n  }\nlet prevX = 0,\n    prevY = 0\nconst paint = (event: MouseEvent, canvas:HTMLCanvasElement) => {\n    const {offsetX, offsetY} = event\n    if (prevX !== offsetX && prevY !== offsetY){\n        prevX = offsetX\n        prevY = offsetY\n        const squareSize = canvas.height / gridSize\n        const xCoord = Math.ceil(offsetX / squareSize) - 1\n        const yCoord = gridSize - Math.ceil(offsetY / squareSize)\n        const index = yCoord * gridSize + xCoord\n        indexArray[index] ^= 1\n        // updateGrid()\n        // indexArray = new Uint32Array(gridSize * gridSize)\n    }\n}\nlet indexArray = new Uint32Array(gridSize * gridSize)\nlet mouseDown = false\ncanvas?.addEventListener('click', (event) => {\n    if (canvas){\n        paint(event, canvas)\n    }\n})\ncanvas?.addEventListener('mousedown', (event) => {\n    mouseDown = true\n})\ncanvas?.addEventListener('mouseup', () => {\n    mouseDown = false\n})\ncanvas?.addEventListener('mousemove', (event) => {\n   if (canvas && mouseDown){\n        paint(event, canvas)\n   }\n})\ndevice.queue.writeBuffer(cellStateStorage[0], 0, cellStateArray);\n\n    // // Mark every other cell of the second grid as active.\n    // for (let i = 0; i < cellStateArray.length; i++) {\n    //     cellStateArray[i] = i % 2;\n    // }\n    device.queue.writeBuffer(cellStateStorage[1], 0, cellStateArray);\n\n    const vertexBufferLayout = {\n        arrayStride: 8,\n        attributes: [{\n            format: \"float32x2\",\n            offset: 0,\n            shaderLocation: 0, // Position, see vertex shader\n        }],\n    };\n\n    const simulationShaderModule = device.createShaderModule({\n        label: \"Simulation Shader\",\n        code: `\n        @group(0) @binding(0) var<uniform> grid: vec2f;\n\n        @group(0) @binding(1) var<storage> cellStateIn: array<u32>;\n        @group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;\n        @group(0) @binding(3) var<storage, read> inputState: array<u32>;\n\n        //find the cell index. handle out of bounds by \"wrapping\" the index around the grid\n        fn cellIndex(cell: vec2u) -> u32 {\n            return (cell.y % u32(grid.y)) * u32(grid.x) +\n                   (cell.x % u32(grid.x));\n          }\n        \n        fn cellActive(x: u32, y: u32) -> u32 {\n            return cellStateIn[cellIndex(vec2(x, y))];\n          }\n\n        @compute @workgroup_size(${workGroupSize}, ${workGroupSize})\n        fn computeMain(@builtin(global_invocation_id) cell: vec3u){\n            let i = cellIndex(cell.xy);\n            let activeNeighbors = cellActive(cell.x+1, cell.y+1) +\n                        cellActive(cell.x+1, cell.y) +\n                        cellActive(cell.x+1, cell.y-1) +\n                        cellActive(cell.x, cell.y-1) +\n                        cellActive(cell.x-1, cell.y-1) +\n                        cellActive(cell.x-1, cell.y) +\n                        cellActive(cell.x-1, cell.y+1) +\n                        cellActive(cell.x, cell.y+1);\n            /* if the user has selected a cell, then the value for that cell index, in the input state, will be 1 for this round of rendering.\n            * then an Xor of the input state and current state will produce the desired result of \n            * flipping the cell state only when the input state is 1. Then the user input takes prefrence of the state update for\n            * this render*/\n            switch activeNeighbors {\n                case 2: {\n                    cellStateOut[i] = inputState[i] ^ cellStateIn[i];\n                }\n                case 3: {\n                    cellStateOut[i] = inputState[i] ^ 1;\n                }\n                default: {\n                    cellStateOut[i] = inputState[i] ^ 0;\n                }\n                }\n                \n        }\n        `\n    })\n\n    const cellShaderModule = device.createShaderModule({\n        label: \"Cell shader\",\n        code: `\n            struct VertexInput {\n                @location(0) pos: vec2f,\n                @builtin(instance_index) instance: u32,\n            };\n            \n            struct VertexOutput {\n                @builtin(position) pos: vec4f,\n                @location(0) cell: vec2f\n            };\n\n            @group(0) @binding(0) var<uniform> grid: vec2f;\n            @group(0) @binding(1) var<storage> cellState: array<u32>;\n\n            @vertex\n            fn vertexMain(input: VertexInput) -> VertexOutput {\n                let i = f32(input.instance);\n                let state = f32(cellState[input.instance]);\n                let cell = vec2f(i % grid.x, floor(i / grid.x));\n                let cellOffset = cell / grid * 2;\n                let gridPos = (input.pos*state+1) / grid - 1 + cellOffset;\n                var output:VertexOutput;\n                output.pos = vec4(gridPos, 0, 1);\n                output.cell = cell;\n                return output;\n            }\n            \n            @fragment\n            fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n                let c = input.cell / grid;\n                return vec4(c, 1 - c.x, 1);\n            }\n        `,\n    });\n\n    const bindGroupLayout = device.createBindGroupLayout({\n        label: \"Cell Bind Group Layout\",\n        entries: [{\n            binding: 0,\n            visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n            buffer: {} // Grid uniform buffer\n        }, {\n            binding: 1,\n            visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\n            buffer: { type: \"read-only-storage\" } // Cell state input buffer\n        }, {\n            binding: 2,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: \"storage\" } // Cell state output buffer\n        }, \n        {\n            binding: 3,\n            visibility: GPUShaderStage.COMPUTE,\n            buffer: { type: \"read-only-storage\" } // Cell state input buffer for user data\n        }\n        ]\n    });\n\n    const bindGroups = [\n        device.createBindGroup({\n            label: \"Cell renderer bind group A\",\n            layout: bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: { buffer: uniformBuffer }\n                },\n                {\n                    binding: 1,\n                    resource: { buffer: cellStateStorage[0] }\n                },\n                {\n                    binding: 2,\n                    resource: { buffer: cellStateStorage[1] }\n                },\n                {\n                    binding: 3,\n                    resource: { buffer: cellStateStorage[2] }\n                }\n            ],\n        }),\n        device.createBindGroup({\n            label: \"Cell renderer bind group B\",\n            layout: bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: { buffer: uniformBuffer }\n                },\n                {\n                    binding: 1,\n                    resource: { buffer: cellStateStorage[1] }\n                },\n                {\n                    binding: 2,\n                    resource: { buffer: cellStateStorage[0] }\n                },\n                {\n                    binding: 3,\n                    resource: { buffer: cellStateStorage[2] }\n                }\n\n            ],\n        })\n    ];\n\n    const pipelineLayout = device.createPipelineLayout({\n        label: \"Cell Pipeline Layout\",\n        bindGroupLayouts: [bindGroupLayout],\n    });\n\n    const simulationPipeline = device.createComputePipeline({\n        label: \"Simulation pipeline\",\n        layout: pipelineLayout,\n        compute: {\n            module: simulationShaderModule,\n            entryPoint: \"computeMain\",\n        }\n    });\n    const cellPipeline = device.createRenderPipeline({\n        label: \"Cell pipeline\",\n        layout: pipelineLayout,\n        vertex: {\n            module: cellShaderModule,\n            entryPoint: \"vertexMain\",\n            buffers: [vertexBufferLayout]\n        },\n        fragment: {\n            module: cellShaderModule,\n            entryPoint: \"fragmentMain\",\n            targets: [{\n                format: canvasFormat\n            }]\n        }\n    });\n\n    const updateInterval = 200\n    let step = 0\n\n    // Move all of our rendering code into a function\n    function updateGrid() {\n\n        // console.log({indexArray})    \n\n        /*  \n            Command buffers are a buffer of commands. You create encoders. \n            The encoders encode commands into the command buffer. \n            You then finish the encoder and it gives you the command buffer it created. \n            You can then submit that command buffer to have WebGPU execute the commands.\n        */\n\n       \n\n\n        device.queue.writeBuffer(cellStateStorage[2], 0, indexArray);\n        const encoder = device.createCommandEncoder();\n        // //start a compute pass\n        const computePass = encoder.beginComputePass();\n\n        computePass.setPipeline(simulationPipeline);\n        computePass.setBindGroup(0, bindGroups[step % 2]);\n        computePass.dispatchWorkgroups(Math.ceil(gridSize / workGroupSize), Math.ceil(gridSize / workGroupSize));\n        computePass.end();\n        indexArray = new Uint32Array(gridSize * gridSize)\n\n        step++; // Increment the step count\n\n        // Start a render pass \n\n        const pass = encoder.beginRenderPass({\n            colorAttachments: [{\n                view: context.getCurrentTexture().createView(),\n                loadOp: \"clear\",\n                clearValue: { r: 0, g: 0, b: 0.4, a: 1.0 },\n                storeOp: \"store\",\n            }]\n        });\n\n        // Draw the grid.\n        pass.setPipeline(cellPipeline);\n        //some logic goes here\n        pass.setBindGroup(0, bindGroups[step % 2]);\n        pass.setVertexBuffer(0, vertexBuffer);\n        pass.draw(vertices.length / 2, gridSize * gridSize);\n\n        // End the render pass and submit the command buffer\n        pass.end();\n         /**\n         * It’s important to emphasize that all of these functions we called like setPipeline, \n         * and draw only add commands to a command buffer. \n         * They don’t actually execute the commands. \n         * The commands are executed when we submit the command buffer to the device queue\n         */\n        device.queue.submit([encoder.finish()]);\n    }\n\n    // Schedule updateGrid() to run repeatedly\n    \n    setInterval(updateGrid, updateInterval);\n    // updateGrid()\n}\napp()"],"names":["async","canvas","document","querySelector","navigator","gpu","Error","adapter","requestAdapter","device","requestDevice","context","getContext","canvasFormat","getPreferredCanvasFormat","configure","format","gridSize","vertices","Float32Array","uniformArray","uniformBuffer","createBuffer","label","size","byteLength","usage","GPUBufferUsage","UNIFORM","COPY_DST","queue","writeBuffer","vertexBuffer","VERTEX","cellStateArray","Uint32Array","cellStateStorage","STORAGE","i","length","Math","random","prevX","prevY","paint","event","offsetX","offsetY","squareSize","height","xCoord","ceil","yCoord","indexArray","mouseDown","addEventListener","simulationShaderModule","createShaderModule","code","cellShaderModule","bindGroupLayout","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","FRAGMENT","buffer","type","bindGroups","createBindGroup","layout","resource","pipelineLayout","createPipelineLayout","bindGroupLayouts","simulationPipeline","createComputePipeline","compute","module","entryPoint","cellPipeline","createRenderPipeline","vertex","buffers","arrayStride","attributes","offset","shaderLocation","fragment","targets","step","setInterval","encoder","createCommandEncoder","computePass","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","end","pass","beginRenderPass","colorAttachments","view","getCurrentTexture","createView","loadOp","clearValue","r","g","b","a","storeOp","setVertexBuffer","draw","submit","finish","$f43313d21d3fd8e2$var$app"],"version":3,"file":"index.2105c214.js.map"}