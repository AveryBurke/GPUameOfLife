!async function(){const e=document.querySelector("canvas");if(!navigator.gpu)throw new Error("WebGPU not supported on this browser.");const t=await navigator.gpu.requestAdapter();if(!t)throw new Error("No appropriate GPUAdapter found.");const n=await t.requestDevice(),r=e.getContext("webgpu"),i=navigator.gpu.getPreferredCanvasFormat();r.configure({device:n,format:i});const l=64,a=new Float32Array([-.8,-.8,.8,-.8,.8,.8,-.8,-.8,.8,.8,-.8,.8]),u=new Float32Array([l,l]),o=n.createBuffer({label:"Grid Uniforms",size:u.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});n.queue.writeBuffer(o,0,u);const c=n.createBuffer({label:"Cell vertices",size:a.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});n.queue.writeBuffer(c,0,a);const s=new Uint32Array(4096),f=[n.createBuffer({label:"Cell State A",size:s.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),n.createBuffer({label:"Cell State B",size:s.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),n.createBuffer({label:"Cell State Input Buffer",size:s.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})];for(let e=0;e<s.length;++e)s[e]=Math.random()>.9?1:0;let d=0,g=0;const p=(e,t)=>{const{offsetX:n,offsetY:r}=e;if(d!==n&&g!==r){d=n,g=r;const e=t.height/l,i=Math.ceil(n/e)-1,a=l-Math.ceil(r/e);b[a*l+i]^=1}};let b=new Uint32Array(4096),h=!1;e?.addEventListener("click",(t=>{e&&p(t,e)})),e?.addEventListener("mousedown",(e=>{h=!0})),e?.addEventListener("mouseup",(()=>{h=!1})),e?.addEventListener("mousemove",(t=>{e&&h&&p(t,e)})),n.queue.writeBuffer(f[0],0,s),n.queue.writeBuffer(f[1],0,s);const v=n.createShaderModule({label:"Simulation Shader",code:'\n        @group(0) @binding(0) var<uniform> grid: vec2f;\n\n        @group(0) @binding(1) var<storage> cellStateIn: array<u32>;\n        @group(0) @binding(2) var<storage, read_write> cellStateOut: array<u32>;\n        @group(0) @binding(3) var<storage, read> inputState: array<u32>;\n\n        //find the cell index. handle out of bounds by "wrapping" the index around the grid\n        fn cellIndex(cell: vec2u) -> u32 {\n            return (cell.y % u32(grid.y)) * u32(grid.x) +\n                   (cell.x % u32(grid.x));\n          }\n        \n        fn cellActive(x: u32, y: u32) -> u32 {\n            return cellStateIn[cellIndex(vec2(x, y))];\n          }\n\n        @compute @workgroup_size(8, 8)\n        fn computeMain(@builtin(global_invocation_id) cell: vec3u){\n            let i = cellIndex(cell.xy);\n            let activeNeighbors = cellActive(cell.x+1, cell.y+1) +\n                        cellActive(cell.x+1, cell.y) +\n                        cellActive(cell.x+1, cell.y-1) +\n                        cellActive(cell.x, cell.y-1) +\n                        cellActive(cell.x-1, cell.y-1) +\n                        cellActive(cell.x-1, cell.y) +\n                        cellActive(cell.x-1, cell.y+1) +\n                        cellActive(cell.x, cell.y+1);\n            /* if the user has selected a cell, then the value for that cell index, in the input state, will be 1 for this round of rendering.\n            * then an Xor of the input state and current state will produce the desired result of \n            * flipping the cell state only when the input state is 1. Then the user input takes prefrence of the state update for\n            * this render*/\n            switch activeNeighbors {\n                case 2: {\n                    cellStateOut[i] = inputState[i] ^ cellStateIn[i];\n                }\n                case 3: {\n                    cellStateOut[i] = inputState[i] ^ 1;\n                }\n                default: {\n                    cellStateOut[i] = inputState[i] ^ 0;\n                }\n                }\n                \n        }\n        '}),y=n.createShaderModule({label:"Cell shader",code:"\n            struct VertexInput {\n                @location(0) pos: vec2f,\n                @builtin(instance_index) instance: u32,\n            };\n            \n            struct VertexOutput {\n                @builtin(position) pos: vec4f,\n                @location(0) cell: vec2f\n            };\n\n            @group(0) @binding(0) var<uniform> grid: vec2f;\n            @group(0) @binding(1) var<storage> cellState: array<u32>;\n\n            @vertex\n            fn vertexMain(input: VertexInput) -> VertexOutput {\n                let i = f32(input.instance);\n                let state = f32(cellState[input.instance]);\n                let cell = vec2f(i % grid.x, floor(i / grid.x));\n                let cellOffset = cell / grid * 2;\n                let gridPos = (input.pos*state+1) / grid - 1 + cellOffset;\n                var output:VertexOutput;\n                output.pos = vec4(gridPos, 0, 1);\n                output.cell = cell;\n                return output;\n            }\n            \n            @fragment\n            fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n                let c = input.cell / grid;\n                return vec4(c, 1 - c.x, 1);\n            }\n        "}),S=n.createBindGroupLayout({label:"Cell Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,buffer:{}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),P=[n.createBindGroup({label:"Cell renderer bind group A",layout:S,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:f[0]}},{binding:2,resource:{buffer:f[1]}},{binding:3,resource:{buffer:f[2]}}]}),n.createBindGroup({label:"Cell renderer bind group B",layout:S,entries:[{binding:0,resource:{buffer:o}},{binding:1,resource:{buffer:f[1]}},{binding:2,resource:{buffer:f[0]}},{binding:3,resource:{buffer:f[2]}}]})],x=n.createPipelineLayout({label:"Cell Pipeline Layout",bindGroupLayouts:[S]}),U=n.createComputePipeline({label:"Simulation pipeline",layout:x,compute:{module:v,entryPoint:"computeMain"}}),m=n.createRenderPipeline({label:"Cell pipeline",layout:x,vertex:{module:y,entryPoint:"vertexMain",buffers:[{arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]}]},fragment:{module:y,entryPoint:"fragmentMain",targets:[{format:i}]}});let G=0;setInterval((function(){n.queue.writeBuffer(f[2],0,b);const e=n.createCommandEncoder(),t=e.beginComputePass();t.setPipeline(U),t.setBindGroup(0,P[G%2]),t.dispatchWorkgroups(Math.ceil(8),Math.ceil(8)),t.end(),b=new Uint32Array(4096),G++;const i=e.beginRenderPass({colorAttachments:[{view:r.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:.4,a:1},storeOp:"store"}]});i.setPipeline(m),i.setBindGroup(0,P[G%2]),i.setVertexBuffer(0,c),i.draw(a.length/2,4096),i.end(),n.queue.submit([e.finish()])}),200)}();
//# sourceMappingURL=index.2105c214.js.map
